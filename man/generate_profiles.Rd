% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/nadda_functionized.R
\name{generate_profiles}
\alias{generate_profiles}
\title{Generate Protein k-mer frequency profiles}
\usage{
generate_profiles(obj, klen = 6, parallel = TRUE, nproc = ifelse(parallel,
  pbdMPI::comm.size(), 1), normalize = TRUE, impute = TRUE, winlen = 20,
  imputing_length = winlen\%/\%2, distributed = FALSE)
}
\arguments{
\item{obj}{A filepath to a fasta file containing protein sequences or an 
AAStringSet object containing the sequences}

\item{klen}{length of the k-mers to be used}

\item{parallel}{Indicating whether the operation should be 
performed in parallel}

\item{nproc}{Currently not supported. Will use all processors 
available to the job on cluster}

\item{normalize}{A boolean value, indicating whether the k-mer 
frequencies should be normalized}

\item{impute}{A boolean value, indicating whether imputed values 
should be inserted at the beginning and the 
end of the profiles}

\item{winlen}{An integer, size the window used for generation 
of each instance}

\item{imputing_length}{An integer, number of frequencies from the 
beginning and end of a sequence profile that should 
be used to impute the new values}

\item{distributed}{A boolean, indicating whether the data is 
spread among multiple processors.}
}
\value{
Returns a list with one vector for each protein sequence in 
the dataset. A vector for sequence \emph{s} 
contains |s| - klen + 1
indices if \emph{impute} is set to \strong{FALSE} (where |s| is the 
length of the sequence). Otherwise it will 
include one index for each position in the sequence but also 
\emph{winlen \%\\\% 2} indices at 
the beginning and end of each sequence.
}
\description{
constructs a dataframe where each row corresponds to one 
index of one protein sequence from the 
input dataset. It can be used to generate training and test sets to train 
a NADDA classification model or to 
predict the conserved indices of input sequences based on a trained model.
}
\details{
If \emph{parallel} is set to \strong{TRUE} and  
\emph{distributed} is set to \strong{FALSE}, the method 
distributes the data between different 
processors and sets \emph{distributed} to \strong{TRUE}. 
Otherwise, if the \emph{parallel} is set to \strong{FALSE} 
and \emph{distributed} is set to \strong{TRUE}, 
the kmer frequencies are computed on each processor separately 
but then communicated between each other, and therefore 
at the end all processors have the same set of frequencies for 
kmers stored, using which they will generate frequency 
profiles for their chunk of sequences.
If you prefer to run the operation in serial, set both \emph{parallel} 
and \emph{distributed} to \strong{FALSE}.
}
\examples{
library(Biostrings)
library(data.table)
## Generate a set of three example protein sequences
seqs <- AAStringSet(c("seq1"="MLVVD",
                      "seq2"="PVVRA",
                      "seq3"="LVVR"))
## Count the kmers and generate a dataframe of the frequencies
profs <- generate_profiles(seqs, klen = 3, parallel = FALSE, winlen = 5, normalize = FALSE)
head(profs)
profs
##[[1]]
##[[1]]$freqs
##[1] 1.5 1.5 1.0 2.0 1.0 1.5 1.5 1.5 1.5
##[[1]]$seq
##[1] "seq1"
##
##[[2]]
##[[2]]$freqs
##[1] 1.5 1.5 1.0 2.0 1.0 1.5 1.5 1.5 1.5
##[[2]]$seq
##[[1]] "seq2"
##
##[[3]]
##[[3]]$freqs
##[1] 2 2 2 2 2 2 2 2 
##[[3]]$seq
##[1] "seq3"
}
\author{
Armen Abnousi
}
